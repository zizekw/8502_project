---
title: "DT Bank Campaign Analysis (RSM8502 Project)"
author: "Group 6"
date: "28/10/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
library(readr)
library(corrplot)
library(tidyverse)
library(ROCR)
library(Metrics)
library(caret)
library(fastDummies)
library(plyr)

knitr::opts_chunk$set(echo = TRUE)
```

```{r import data, message=FALSE}
bank_additional_full <- read_delim("data/bank-additional-full.csv", 
    ";", escape_double = FALSE, trim_ws = TRUE)

data <- bank_additional_full
```

# Variable Definitions

### General input attributes:
age (numeric)

job - type of job (categorical: "admin.","blue-collar","entrepreneur","housemaid","management","retired","self-employed","services","student","technician","unemployed","unknown")

marital : marital status (categorical: "divorced","married","single","unknown"; note: "divorced" means divorced or widowed)

education (categorical: "basic.4y","basic.6y","basic.9y","high.school","illiterate","professional.course","university.degree","unknown") 

default: has credit in default? (categorical: "no","yes","unknown")

housing: has housing loan? (categorical: "no","yes","unknown")

loan: has personal loan? (categorical: "no","yes","unknown")

### Input attributes related to the last contact of the current campaign:
contact: contact communication type (categorical: "cellular","telephone")

month: last contact month of year (categorical: "jan", "feb", "mar", ..., "nov", "dec")

day_of_week: last contact day of the week (categorical: "mon","tue","wed","thu","fri")

duration: last contact duration, in seconds (numeric). Important note: the duration variable is unknown before the sales call is finished

### Historical attributes (campaign related):
campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)

pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric; 999 means client was not previously contacted)

previous: number of contacts performed before this campaign and for this client (numeric)

poutcome: outcome of the previous marketing campaign (categorical: "failure","nonexistent","success")

### Socio-economic context variables:
emp.var.rate: employment variation rate - quarterly indicator (numeric)

cons.price.idx: consumer price index - monthly indicator (numeric)     

cons.conf.idx: consumer confidence index - monthly indicator (numeric)     

euribor3m: euribor 3 month rate - daily indicator (numeric)

nr.employed: number of employees - quarterly indicator (numeric)


# Question 1

## Question 1a
Check for linear correlations between the input variables (numeric). We should also make a correction for `pdays` since many values are inputted as `999` and this may impact our colinearity assessment.

```{r 1a}
# remove non-numeric columns
data_numeric_only <- data %>% select_if(is.numeric)

# now we can create our corrplot
M <- cor(data_numeric_only)
corrplot(M, method = "number", tl.col = "black", type = "upper")
```
Yes, there are a few variables positively correlated with each other and a select few negatively correlated. Of note, `emp.var.rate` is positively correlated with `cons.price.idx`, `euribor3m`, and `nr.employed` >0.78 for each.

## Question 1b

`Jax input`

## Question 1c

```{r 1c}
# Extract each group
group1 = subset(data, select = c("age","job","marital","education","default","housing","loan"))
group2 = subset(data, select = c("contact","month","day_of_week","duration"))
group3 = subset(data, select = c("campaign","pdays","previous","poutcome"))
group4 = subset(data, select = c("emp.var.rate","cons.price.idx","cons.conf.idx","euribor3m","nr.employed"))
outcome = subset(data, select = c("y"))

data_categorical_only <- select_if(data, is.character)

# Test independence by using Chi-square test)
for(col in names(data_categorical_only)){
  if (col != "y"){
    test_data = subset(data, select = c(col, "y"))
    print(table(test_data))
    print(chisq.test(table(test_data)))
  }
}
```


## Question 1d

## Question 2a
```{r}
# handle '999' placeholder for pdays
# explor pdays column
count(data$pdays)
# change '999' to NA
data$pdays[data$pdays == 999] = NA
```
```{r}

```



```{r}
# prepare data for glm()

# create dummy variables for categorical variables
glm_data = dummy_cols(data, select_columns = c('job', 'marital', 
                                              'education', 'default', 'contact', 
                                              'month', 'day_of_week', 'poutcome'),remove_selected_columns = TRUE)

# change responde variable 'y' from yes/no to 1/0
glm_data$y = revalue(glm_data$y, c("yes"=1))
glm_data$y = revalue(glm_data$y, c("no"=0))
glm_data$y = as.numeric(glm_data$y) 

# remove dependent vairables that we dont want to include
#sapply(glm_data, class)
# remove Group 4 variables
glm_data = subset(glm_data, select = -c(emp.var.rate, cons.price.idx, cons.conf.idx,euribor3m, nr.employed ))
#glm_data = glm_data[,-c(8:12)]
# remove "duration"
glm_data = subset(glm_data, select = -c(duration))
#glm_data = glm_data[,-c(4)]

# split into test and training dataset
smp_size = floor(0.75 * nrow(glm_data))
set.seed(123)
train_ind =  sample(seq_len(nrow(glm_data)), size = smp_size)
train = glm_data[train_ind, ]
test = glm_data[-train_ind, ]
```

Do regrssion use all numeric and categorical variables
```{r}
# fit logistic regression model
glm_fit1 = glm(formula = y~ ., 
          data = train, family=binomial)
summary(glm_fit1)
```

From the result, we can see 'pdays' is insiginificent, we can remove this factor based on backward elimination.
```{r}
# remove pdays
glm_data = subset(glm_data, select = -c(pdays))

# split into test and training dataset
smp_size = floor(0.75 * nrow(glm_data))
set.seed(123)
train_ind =  sample(seq_len(nrow(glm_data)), size = smp_size)
train = glm_data[train_ind, ]
test = glm_data[-train_ind, ]
# fit logistic regression model
glm_fit2 = glm(formula = y~ ., 
          data = train, family=binomial)
summary(glm_fit2)
```


```{r}
# make prediction on test data, threshold = 0.5
glm_predict = predict(glm_fit, newdata = test, type = "response")
glm_predict = ifelse(glm_predict > 0.5,1,0)
# create confustion matrix/classification table
confusionMatrix(data = as.factor(glm_predict) , 
                reference = as.factor(test$y))
# generate ROC curve
glm_preobj = prediction(predictions = glm_predict, labels = test$y)
glm_perf = performance(glm_preobj, measure = "tpr",x.measure = "fpr")
plot(glm_perf)
auc(glm_predict,test$y)
```

